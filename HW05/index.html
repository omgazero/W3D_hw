<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HW05</title>
</head>

<body>
  <div id="container" style="float:left; margin:2px; width:60vw; height:60vw"></div>
  <div style="float:left;width:30vw;">
    <input type="button" value="Step" style="font-size:20px;width:100%;" id="step">
    <p id="fuel"></p><br>
    <p id="omega"></p>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
  <script type="text/javascript">
    var frame, scene, camera, renderer, light, controls;
    var cars = [];
    var keyboard;
    var myID, otherID = [];
    class Car {
      constructor(R, mesh) {
        /*this.mesh = new THREE.Mesh(new THREE.CircleGeometry(5, 20), new THREE.MeshBasicMaterial());
        this.mesh.rotation.x = -Math.PI/2;*/
        this.mesh = mesh;
      //  this.mesh.material.visible = false;
        scene.add(this.mesh);

        this.engine = true;
        this.fuel = 100;
        this.omega = 0;
        this.theta = 0;
        this.R = R;
        this.clock = new THREE.Clock();
        this.step = false;
      }
      update() {

        let dt = this.clock.getDelta();

        if (this.engine) {

          this.theta += this.omega * dt;

          let dx = ( -Math.cos(this.theta*this.R) * Math.sin(this.theta) ) - ( this.R*Math.cos(this.theta)*Math.sin(this.theta*this.R) );
 		       let dy = ( Math.cos(this.theta*this.R) * Math.cos(this.theta) ) - ( this.R*Math.sin(this.theta)*Math.sin(this.theta*this.R)) ;

          this.mesh.position.set(this.R * Math.cos(this.theta), 0, -this.R * Math.sin(this.theta));
          this.mesh.rotation.y = -Math.atan2 ( dy, dx);

          if (this.step) {
            this.omega += 0.1;
            this.fuel -= 0.3;
            if (this.omega > 4) this.omega = 4;
          } else {
            this.fuel -= 0.03;
            this.omega -= 0.02;
            if (this.omega < 0) this.omega = 0;
          }

          if (this.fuel < 0) {
            this.engine = false;
            this.fuel = 0;
          }
        }

      }
    }


    $(function() {
      var socket = io();
      socket.on('ID', function(e) {
        myID = e;
        console.log('myID = ' + myID);
      });

      $("#step").on('mousedown', function(e) {
        console.log('mouse down')
        cars[myID].step = true;
        msg = {
          id: myID,
          step: cars[myID].step
        };
        socket.emit('step', msg);
      }).on('mouseup', function(e) {
        console.log('mouse up')
        cars[myID].step = false;
        msg = {
          id: myID,
          step: cars[myID].step
        };
        socket.emit('step', msg);
      });

      socket.on('update_status', function(status) {
        for (let i = 0; i < status.length; i++) {
          cars[status[i].id].mesh.material.visible = true;
          if (i !== myID) {
            cars[status[i].id].step = status[i].step;
          }
        }

      });
    });




    init();
    animate();

    function init() {

      var ww = $("#container").innerWidth();
      var hh = $("#container").innerHeight();
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(ww, hh);
      renderer.setClearColor(0x888888);
      $("#container").append(renderer.domElement);

      ////////////////////////////////////////////////

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, ww / hh, 1, 1000);
      camera.position.set(0, 500, 0);

      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(-15, 15, 15);
      scene.add(light);

      readModel('car');

      var gridXZ = new THREE.GridHelper(500, 20, 'red', 'white');
      scene.add(gridXZ);

      let controls = new THREE.OrbitControls(camera, renderer.domElement);
      keyboard = new KeyboardState();
      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {

      cars.forEach(function(e) {
        e.update();
      });
      if (myID != undefined) {
        $('#fuel').text(cars[myID].fuel.toFixed(2));
        $('#omega').text(cars[myID].omega.toFixed(2));
      }
      /*  keyboard.update();
        if (keyboard.pressed("S"))
          step = true;
        else
          step = false;*/
      requestAnimationFrame(animate);
      render();
    }

    function render() {

      renderer.render(scene, camera);
    }

    /// ReadModels
    function readModel(modelName, targetSize = 40) {
      var onProgress = function(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };
      var onError = function(xhr) {};
      var mtlLoader = new THREE.MTLLoader();
      mtlLoader.setPath('https://omgazero.github.io/W3D_hw/models/');
      mtlLoader.load(modelName + '.mtl', function(materials) {
        materials.preload();
        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath('https://omgazero.github.io/W3D_hw/models/');
        objLoader.load(modelName + '.obj', function(object) {

          let theObject = unitize(object, targetSize);
          theObject.rotation.x = Math.PI / 2;
          cars[0] = new Car(10, object.clone());
          cars[1] = new Car(70, object.clone());
          cars[2] = new Car(130, object.clone());
          cars[3] = new Car(190, object.clone());

        }, onProgress, onError);
      });
    }

    function unitize(object, targetSize) {

      // find bounding box of 'object'
      var box3 = new THREE.Box3();
      box3.setFromObject(object);
      var size = new THREE.Vector3();
      size.subVectors(box3.max, box3.min);
      var center = new THREE.Vector3();
      center.addVectors(box3.max, box3.min).multiplyScalar(0.5);

      console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
      console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);

      // uniform scaling according to objSize
      var objSize = Math.max(size.x, size.y, size.z);
      var scaleSet = targetSize / objSize;

      var theObject = new THREE.Object3D();
      theObject.add(object);
      object.scale.set(scaleSet, scaleSet, scaleSet);
      object.position.set(-center.x * scaleSet, -center.y * scaleSet + 10, -center.z * scaleSet);

      return theObject;

    }

    ///

    function onWindowResize() {

      var ww = $("#container").innerWidth();
      var hh = $("#container").innerHeight();

      camera.aspect = ww / hh;
      camera.updateProjectionMatrix();
      renderer.setSize(ww, hh);
    }
  </script>
</body>

</html>
